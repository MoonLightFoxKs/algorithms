#include <iostream>
using namespace std;

class bin_note                             //Звено дерева
{
public:
    int x;              //сам эл-т
    bin_note *l,*r;    //адреса дочерних узлов (l-левое ,r-правое)
};

 void show(bin_note *&Tree){         //ф-я обхода
        if (Tree != NULL) {              //Пока не встретится пустое звено
            show(Tree->l);               //Рекурсивная функция для вывода левого поддерева
            cout<<Tree->x<<" ";               //Отображаем корень дерева
            show(Tree->r); //Рекурсивная функци для вывода правого поддерева
        }
    }
    
    
    void add_node(int x,bin_note *&MyTree) //Фукция добавления звена в дерево
    {
        if (NULL == MyTree)             //Если дерева нет, то создаем корневой эл-т
        {
            MyTree = new bin_note;          //Выделяем память под звено дерева
            MyTree->x = x;              //Записываем данные в звено
            MyTree->l = MyTree->r = NULL; //Подзвенья инициализируем пустотой
        }
        
        if (x < MyTree->x)   //Если нововведенный элемент x меньше чем элемент x из корня дерева, уходим влево
        {
            if (MyTree->l != NULL) add_node(x, MyTree->l); //При помощи рекурсии находим место для нового эл-а
            else          //Если элемент получил свой участок, то
            {
                MyTree->l = new bin_note;                 //Выделяем память левому подзвену
                MyTree->l->l = MyTree->l->r = NULL;   //У левого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
                MyTree->l->x = x;                     //Записываем в левое подзвено записываемый элемент
            }
        }
        
        if (x > MyTree->x)  //Если нововведенный элемент x больше чем элемент x из корня дерева, уходим вправо
        {
            if (MyTree->r != NULL) add_node(x, MyTree->r); //При помощи рекурсии находим место для нового эл-а
            else              //Если элемент получил свой участок, то
            {
                MyTree->r = new bin_note;                 //Выделяем память правому подзвену.
                MyTree->r->l = MyTree->r->r = NULL;   //У правого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
                MyTree->r->x = x;                     //Записываем в правое подзвено записываемый элемент
            }
        }
    }



int main()
{
    
    bin_note *Tree = NULL;               // указатель, тип которого = звено дерева и инициализирем его пустотой
    for (int i=5; i>0; i--) add_node(i,Tree);
    add_node(9, Tree);
    add_node(7, Tree);
    show(Tree);
    cout<<endl;
    
}
